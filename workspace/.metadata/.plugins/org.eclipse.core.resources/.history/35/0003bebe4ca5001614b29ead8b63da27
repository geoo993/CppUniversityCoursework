/*
 * sample.h
 *
 *  Created on: 4 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef SAMPLE_H_
#define SAMPLE_H_

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>

using namespace std;

class Sample {
private:
	int input;
	const int N { 100 };
	vector <long double> y;


public:

	Sample();

	Sample(vector<long double> y);

	//Sample(const Sample &other)= default;//copy constructor
	Sample(const Sample &other);

	Sample(Sample &&other);//move copy constructor

	//Sample &operator=(const Sample &other)= default;//assigment operator to default
	Sample &operator=(const Sample &other);//assignment constructor

	Sample &operator=(Sample &&other);//move assignment operator


	int get_N();
	int get_size();
	void set_data(vector<long double> y);
	vector<long double> get_data();
	long double find_data(int value);
	long double minimum();
	long double maximum();
	long double range();
	long double midRange();
	long double sum();
	long double mean();
	long double median();
	long double mode();
	long double variance();
	long double std_deviation();
	void sort();//ascending order
	long double calculateAverage(const long double &a, const long double &b);


	Sample print();
	void normalPrint();

	virtual ~Sample();

	// the put to (<<) operator, so you can use objects of this class with cout
	friend ostream &operator<<(ostream &out, const Sample &test);
	friend istream &operator>>(istream &in, const Sample &sample);


};




template<typename T>
class Samplet {
private:

	unsigned int m_pos;//position in the array
	unsigned int m_size; //size of the array (elements)
	unsigned int m_realsize; // actual size of allocated memory
	const static int dyn_array_step = 128; // initial size of array memory (elements)
	const static int dyn_array_mult = 2; // multiplier (enlarge array memory
	// dyn_array_mult times  )
	T *m_values;

public:

	class iterator;

public:

	enum exception { MEMFAIL }; // exception enum

	Samplet()//constructor
	{
		m_pos = 0;
		m_realsize = dyn_array_step; // First, allocate step
		// for dyn_array_step items
		m_size = 0;
		m_values = (T *) malloc(m_realsize * sizeof(T));

		if (m_values == NULL)
			throw MEMFAIL;

		cout << " Constructor" << endl;
	}
	~Samplet() {

		//		if (m_values) {
		//			free( m_values); // Freeing memory
		//			m_values = NULL;
		//		}

		delete[] m_values;
	}

	Samplet(const Samplet &other){
		m_values = (T *) malloc(sizeof(T) * other.m_realsize);
		if (m_values == NULL)
			throw MEMFAIL;

		memcpy(m_values, other.m_values, sizeof(T) * other.m_realsize);
		// memcpy call -- coping memory contents
		m_realsize = other.m_realsize;
		m_size = other.m_size;
		m_pos = other.m_pos;

		cout << "Copy Constructor" << endl;
	}

	Samplet(unsigned int m_size) :
		m_pos(0), m_size(m_size), m_realsize(dyn_array_step), m_values(NULL) {

		m_values = new T[m_size];
	}

	Samplet(initializer_list<T> values)//constructor
	{
		m_pos = 0;
		m_realsize = dyn_array_step;
		m_size = 0;
		m_values = values;

		for(auto value: values){

			m_values[m_pos] = value;
			m_pos ++;
			m_size ++;
		}

		if (m_values == NULL)
			throw MEMFAIL;

		cout << " Constructor with Initialiser List" << endl;
	}

	//containers
public:

	void print(){

		for(Samplet<T>::iterator it = begin(); it != end(); it++ ){
			cout << *it << endl;
		}

	}

	void * pGet()
	{
	    return m_values; // return void* pointer
	}

	unsigned int size() const {//get the size of the array
		return m_size;
	}


	void clear() {// clear array memory

		m_size = 0;
		m_values = (T *)realloc(m_values, sizeof(T)*dyn_array_step);
					  // set initial memory size again
		m_realsize = dyn_array_step;
	}


	T &get(unsigned int index) {// get element in array with get
		return m_values[index];
	}

	void setSize(unsigned int newsize) // set size of array (elements)
	{
		m_size = newsize;

		if (m_size != 0)
		{
			// change array memory size
			// if new size is larger than current
			// or new size is less then half of the current
			if ((m_size > m_realsize) || (m_size < m_realsize/2))
			{
		    	m_realsize = m_size;
		    	m_values = (T *)realloc(m_values, sizeof(T)*m_size);

				if (m_values == NULL)
					throw MEMFAIL;
			}
		}
		else
			clear();
	}

	//sequences
public:

	T & front() {
		return operator[](0);
	}
	const T & front() const {
		return operator[](0);
	}
	T & back() {
		return operator[](size() - 1);
	}
	const T & back() const {
		return operator[](size() - 1);
	}

	void add(const T & value) {

		m_size++;

	    if (m_size > m_realsize)
	    {
			m_realsize *= dyn_array_mult;

			m_values = (T *)realloc(m_values, sizeof(T) * m_realsize);

			if (m_values == NULL)
				throw MEMFAIL;
	    }

	    m_values[m_size-1] = value;


	}

	void erase(unsigned int pos) { //delete array item

		if (m_size == 1) // If array has only one element
			clear(); // than we clear it, since it will be deleted
		else
		{
			// otherwise, shift array elements
			for(unsigned int i=pos; i<m_size-1; i++)
				m_values[i] = m_values[i+1];

			// decrease array size
			m_size--;
		}
	}



	//operators
public :
	const Samplet &operator=(const Samplet &other) // assignment operator
	{
	    if (this == &other) // in case somebody tries assign array to itself
			return *this;

		if (other.m_size == 0) // is other array is empty -- clear this array
			clear();

		setSize(other.m_size); // set size

	    memcpy(m_values, other.m_values, sizeof(T)*other.m_size);

	    cout << "Assignment running" << endl;

	    return *this;
	}

	T &operator [](unsigned int index) // get array item
	{
	    return m_values[index]; // return array element
	}

	//iterator
public :
	iterator begin(){
		return iterator(0, *this);
	}
	iterator end(){
		return iterator(m_size, *this);
	}

};


template<typename T>
class Samplet<T>::iterator {

private:
	unsigned int pos;
	Samplet &m_samplet;

public:
	iterator(unsigned int pos, Samplet &s): pos(pos), m_samplet(s){

	}

	iterator &operator++() //prefix operator implementation
	{
		pos++;
		return *this;
	}
	iterator &operator++(int)//postfix operator implementation
	{
		pos++;
		return *this;
	}

	bool operator!=(const iterator &other) const//not equal operator implementation
	{
		return (pos != other.pos);
	}

	bool operator==(const iterator &other) const//equals operator implementation
	{
		return pos == other.pos;
	}

	T &operator*(){
		return m_samplet.get(pos);
	}



};


#endif /* SAMPLE_H_ */
