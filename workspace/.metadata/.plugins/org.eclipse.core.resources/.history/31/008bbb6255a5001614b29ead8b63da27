/*
 * samplet.h
 *
 *  Created on: 8 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef SAMPLET_H_
#define SAMPLET_H_

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>

using namespace std;


template<typename T>
class Samplet {
private:
	int input;
	const int N { 100 };
	vector <T> y;


public:

	Samplet(): input(T()) {
		//cout << "Constructor " << endl;
		y.resize(N);
	}

	Samplet(vector<T> y){
		//cout << "Constructor with Parameters" << endl;
		this -> y.resize(N);
		this -> y = y;

		input = T();
	}

	Samplet(const Samplet &other) {
		//cout << "Copy Constructor" << endl;
		y = other.y;
		input = other.input;
	}

	Samplet(Samplet &&other){
		//cout << "Move Copy Constructor" << endl;
		y = other.y;
		input = other.input;
	}

	Samplet &operator=(const Samplet &other)
	{
		//cout << "Assignment Constructor" << endl;
		y = other.y;

		return *this;
	}

	Samplet &operator=(Samplet &&other) {
		//cout << "Move Assignment Constructor" << endl;
		y = other.y;

		return *this;
	}

	int get_N() {
		return this->N;
	}

	void set_data(vector<T> y) {
		this->y = y;
	}

	vector<T> get_data() {
		return y;
	}

	void sort() {//ascending order
		::sort(y.begin(), y.end());
	}

	int get_size() {
		return y.size();
	}

	T find_data(int value);
	T minimum();
	T maximum();
	T range();
	T midRange();
	T sum();
	T mean();
	T median();
	T mode();
	T variance();
	T std_deviation();


	T calculateAverage(const T &a, const T &b) {

		return (a + b) / 2.0;
	}


	void normalPrint() {

		for(auto vec: y) {
			cout << vec << endl;
		}
	}

	Samplet print() {

		Samplet samplePrint(y);

		cout << "< " << 2 << ": " << flush;

		for (int i = 0; i < samplePrint.y.size(); i++) {
			cout << samplePrint.y[i] << ", " << flush;
		}

		cout << " >" << endl;

		//2
		cout << samplePrint << endl;

		return samplePrint;
	}

	~Samplet() {
		//cout << "Destructor " << endl;
	}



	// the put to (<<) operator, so you can use objects of this class with cout
	friend ostream &operator<<(ostream &out, const Samplet &test);
	friend istream &operator>>(istream &in, const Samplet &sample);

	class iterator;

	iterator begin(){
		return iterator(0, *this);
	}
	iterator end(){
		return iterator(get_size(), *this);
	}

};

ostream &operator<<(ostream &out, const Samplet &sample) {

	out << "Cout Ostream Overload operator of Samplet" << endl;

	return out;
}

istream &operator>>(istream &in, const Samplet &sample) {

	int i;
	vector<T> vec;

	do {

		cout << "Enter Values in Vector > " << flush;

		cin >> i;
		vec.push_back((T)(i));

	} while (i < 10);

	for (int i = 0; i < vec.size(); i++){
		cout << vec[i] << " ";
	}


	return in;
}


template<typename T>
class Samplet<T>::iterator {

private:
	unsigned int pos;
	Samplet &m_samplet;

public:
	iterator(unsigned int pos, Samplet &s): pos(pos), m_samplet(s){

	}

	iterator &operator++() //prefix operator implementation
	{
		pos++;
		return *this;
	}
	iterator &operator++(int)//postfix operator implementation
	{
		pos++;
		return *this;
	}

	bool operator!=(const iterator &other) const//not equal operator implementation
	{
		return (pos != other.pos);
	}

	bool operator==(const iterator &other) const//equals operator implementation
	{
		return pos == other.pos;
	}

	T &operator*(){
		return m_samplet.get(pos);
	}



};

#endif /* SAMPLET_H_ */
