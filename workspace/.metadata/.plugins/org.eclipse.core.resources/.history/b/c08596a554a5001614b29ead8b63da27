/*
 * samplet.h
 *
 *  Created on: 8 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef SAMPLET_H_
#define SAMPLET_H_

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>

using namespace std;


template<typename T>
class Samplet {
private:
	int input;
	const int N { 100 };
	vector <T> y;


public:

	Samplet(): input(T()) {
		//cout << "Constructor " << endl;
		y.resize(N);
	}

	Samplet(vector<T> y){
		//cout << "Constructor with Parameters" << endl;
		this -> y.resize(N);
		this -> y = y;

		input = T();
	}

	Samplet(const Samplet &other) {
		//cout << "Copy Constructor" << endl;
		y = other.y;
		input = other.input;
	}

	Samplet(Samplet &&other){
		//cout << "Move Copy Constructor" << endl;
		y = other.y;
		input = other.input;
	}

	Samplet &Samplet::operator=(const Samplet &other)
	{
		//cout << "Assignment Constructor" << endl;
		y = other.y;

		return *this;
	}

	Samplet &Samplet::operator=(Samplet &&other) {
		//cout << "Move Assignment Constructor" << endl;
		y = other.y;

		return *this;
	}

	int get_N();
	int get_size();
	void set_data(vector<T> y);
	vector<T> get_data();
	T find_data(int value);
	T minimum();
	T maximum();
	T range();
	T midRange();
	T sum();
	T mean();
	T median();
	T mode();
	T variance();
	T std_deviation();
	void sort();//ascending order
	T calculateAverage(const T &a, const T &b);


	Samplet print();
	void normalPrint();

	virtual ~Samplet();

	// the put to (<<) operator, so you can use objects of this class with cout
	friend ostream &operator<<(ostream &out, const Samplet &test);
	friend istream &operator>>(istream &in, const Samplet &sample);

	class iterator;
//	iterator begin(){
//		return iterator(0, *this);
//	}
//	iterator end(){
//		return iterator(m_size, *this);
//	}

};


template<typename T>
class Samplet<T>::iterator {

private:
	unsigned int pos;
	Samplet &m_samplet;

public:
	iterator(unsigned int pos, Samplet &s): pos(pos), m_samplet(s){

	}

	iterator &operator++() //prefix operator implementation
	{
		pos++;
		return *this;
	}
	iterator &operator++(int)//postfix operator implementation
	{
		pos++;
		return *this;
	}

	bool operator!=(const iterator &other) const//not equal operator implementation
	{
		return (pos != other.pos);
	}

	bool operator==(const iterator &other) const//equals operator implementation
	{
		return pos == other.pos;
	}

	T &operator*(){
		return m_samplet.get(pos);
	}



};

#endif /* SAMPLET_H_ */
